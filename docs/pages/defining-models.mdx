---
title: Defining Models
---

import { Header } from '../doc-gen/site/header.js'

Esix provides a beautiful, simple, ActiveRecord like interface for working with your database. In code, you create "Models" that maps on to documents in your database. You then use these models to interact with the collections.

Models are the entry point for working with data in Esix so let's create our first model.

```ts
import { BaseModel } from 'esix'

class BlogPost extends BaseModel {
  public title = ''
  public publishedAt = 0
}

```

By defining a model and extending the `BaseModel` class, you get access to all of Esix's functionality and you can use it to [Create, Update](/creating-and-updating-data) and [Query](/reading-data) documents from the database.

The model will have an `id` property which will be assinged an [ObjectId](https://docs.mongodb.com/manual/reference/method/ObjectId/).

<Header title='Timestamps' />

We keep track of changes to your data during the models lifecycle. When a model is created, the `createdAt` property will be populated with the current timestamp. Every time you update or save your model, the `updatedAt` property will have the current timestamp.

Both values contain the current time in milliseconds since January 1st, 1970, using JavaScript's [Date.now](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now) function.

<Header title='Collections' />

The collection the models act upon is determined by the name of the class. The class name is transformed into a dasherized and pluralized version. That name is used for all operations against the database.

For example, if you have a class named `BlogPost`, the collection name will be `blog-posts`.  This is due to Esix's strong belief in [Convention over Configuration](https://en.wikipedia.org/wiki/Convention_over_configuration).
